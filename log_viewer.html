<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Harmony Log Viewer</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2em; background: #f9f9f9; }
    h1 { margin-bottom: 1em; }
    .upload-btn { margin-bottom: 1em; }
    table { border-collapse: collapse; width: 100%; background: #fff; }
    th, td { border: 1px solid #ddd; padding: 8px; }
    th { background: #f2f2f2; }
    tr:hover { background: #e6f7ff; cursor: pointer; }
    th.time-col, td.time-col { min-width: 170px; white-space: nowrap; }
    .modal {
      display: none; position: fixed; z-index: 10; left: 0; top: 0; width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.4); align-items: center; justify-content: center;
    }
    .modal-content {
      background: #fff; padding: 2em; border-radius: 8px; max-width: 600px; width: 90vw;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
    .close-btn { float: right; font-size: 1.2em; cursor: pointer; color: #888; }
    pre { background: #f4f4f4; padding: 1em; border-radius: 6px; overflow-x: auto; }
  </style>
</head>
<body>
  <div style="display:flex; gap:2em; align-items:flex-start;">
    <div id="fileListContainer" style="min-width:220px;max-width:300px;width:20vw;background:#f4f4f4;padding:1em 0.5em 1em 1em;border-radius:8px;box-shadow:0 1px 4px #0001;">
      <h2 style="font-size:1.1em;margin-top:0;">Files</h2>
      <ul id="fileList" style="list-style:none;padding:0;margin:0;"></ul>
    </div>
    <div style="flex:1;">
      <h1>Harmony Log Viewer</h1>
      <div style="margin-bottom:1em; padding: 1em 1.5em; border-radius: 12px; background: #f7fafc; box-shadow: 0 1px 4px #0001; display:flex; gap:1em; flex-wrap:wrap; align-items:center;">
        <label>Level:
          <select id="filterLevel">
            <option value="">All</option>
          </select>
        </label>
        <label>Message contains:
          <input type="text" id="filterMessage" placeholder="Type to filter...">
        </label>
        <label>Module:
          <select id="filterModule">
            <option value="">All</option>
          </select>
        </label>
        <label>Submodule:
          <select id="filterSubmodule">
            <option value="">All</option>
          </select>
        </label>
        <label>Shard:
          <select id="filterShard">
            <option value="">All</option>
          </select>
        </label>
        <label style="display:flex; align-items:center; gap:0.5em;">
          <input type="checkbox" id="filterAfterShutdown" style="margin:0;">
          <span>After last shutdown</span>
        </label>
        <div style="display:flex; align-items:center; gap:1em; margin-top:0.5em;">
          <label style="display:flex; align-items:center; gap:0.5em;">
            <span>Page size:</span>
            <select id="pageSize" style="padding:0.2em;">
              <option value="100">100</option>
              <option value="500" selected>500</option>
              <option value="1000">1,000</option>
              <option value="5000">5,000</option>
            </select>
          </label>
          <span id="paginationInfo" style="color:#666; font-size:0.9em;"></span>
        </div>
        <button id="clearFilters">Clear</button>
      </div>
      <input class="upload-btn" type="file" id="fileInput" accept=".log,.txt,.jsonl" multiple>
      <table id="logTable">
        <thead>
          <tr>
            <th style="min-width:60px">#</th>
            <th class="time-col">Time</th>
            <th>Level</th>
            <th>ShardID</th>
            <th>Message</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      
      <!-- Pagination Controls -->
      <div style="display:flex; justify-content:space-between; align-items:center; margin-top:1em; padding:1em; background:#f8f9fa; border-radius:8px;">
        <div style="display:flex; align-items:center; gap:0.5em;">
          <button id="firstPage" style="padding:0.5em 1em; border:1px solid #ddd; background:#fff; cursor:pointer; border-radius:4px;">« First</button>
          <button id="prevPage" style="padding:0.5em 1em; border:1px solid #ddd; background:#fff; cursor:pointer; border-radius:4px;">‹ Prev</button>
        </div>
        <div style="display:flex; align-items:center; gap:0.5em;">
          <span>Page</span>
          <input type="number" id="currentPage" min="1" style="width:60px; padding:0.3em; text-align:center; border:1px solid #ddd; border-radius:4px;">
          <span>of <span id="totalPages">1</span></span>
        </div>
        <div style="display:flex; align-items:center; gap:0.5em;">
          <button id="nextPage" style="padding:0.5em 1em; border:1px solid #ddd; background:#fff; cursor:pointer; border-radius:4px;">Next ›</button>
          <button id="lastPage" style="padding:0.5em 1em; border:1px solid #ddd; background:#fff; cursor:pointer; border-radius:4px;">Last »</button>
        </div>
      </div>

      <div class="modal" id="modal">
        <div class="modal-content">
          <span class="close-btn" id="closeModal">&times;</span>
          <h2>Log Entry Details</h2>
          <pre id="jsonDetails"></pre>
        </div>
      </div>
    </div>
  </div>
  <div id="loadingOverlay" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(255,255,255,0.7);z-index:100;align-items:center;justify-content:center;">
    <div style="background:#fff;padding:2em 2em 1.5em 2em;border-radius:10px;box-shadow:0 2px 12px #0002;min-width:300px;text-align:center;">
      <div style="margin-bottom:1em;font-size:1.2em;">Loading file...</div>
      <div id="loadingInfo" style="margin-bottom:1em;font-size:0.9em;color:#666;"></div>
      <div style="width:100%;background:#eee;border-radius:6px;overflow:hidden;height:22px;">
        <div id="progressBar" style="height:22px;width:0;background:#4bb1fa;transition:width 0.2s;"></div>
      </div>
      <div id="progressText" style="margin-top:0.5em;font-size:0.95em;color:#555;">0%</div>
    </div>
  </div>
  <div id="errorOverlay" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(255,0,0,0.07);z-index:200;align-items:center;justify-content:center;">
    <div style="background:#fff;padding:2em 2em 1.5em 2em;border-radius:10px;box-shadow:0 2px 12px #0002;min-width:320px;text-align:center;border:2px solid #e57373;">
      <div style="font-size:1.3em;color:#d32f2f;margin-bottom:0.7em;"><b>Failed to load log file</b></div>
      <div id="errorMessage" style="color:#b71c1c;font-size:1.05em;margin-bottom:1.2em;"></div>
      <button onclick="document.getElementById('errorOverlay').style.display='none'" style="background:#e57373;color:#fff;border:none;padding:0.5em 1.5em;border-radius:5px;font-size:1em;cursor:pointer;">Close</button>
    </div>
  </div>
  <script>
    const fileInput = document.getElementById('fileInput');
    const fileList = document.getElementById('fileList');
    const logTableBody = document.querySelector('#logTable tbody');
    const modal = document.getElementById('modal');
    const closeModal = document.getElementById('closeModal');
    const jsonDetails = document.getElementById('jsonDetails');
    const filterLevel = document.getElementById('filterLevel');
    const filterMessage = document.getElementById('filterMessage');
    const filterModule = document.getElementById('filterModule');
    const filterSubmodule = document.getElementById('filterSubmodule');
    const filterShard = document.getElementById('filterShard');
    const filterAfterShutdown = document.getElementById('filterAfterShutdown');
    const pageSize = document.getElementById('pageSize');
    const paginationInfo = document.getElementById('paginationInfo');
    const firstPage = document.getElementById('firstPage');
    const prevPage = document.getElementById('prevPage');
    const currentPage = document.getElementById('currentPage');
    const totalPages = document.getElementById('totalPages');
    const nextPage = document.getElementById('nextPage');
    const lastPage = document.getElementById('lastPage');
    const clearFilters = document.getElementById('clearFilters');
    let logEntries = [];
    let uniqueLevels = new Set();
    let uniqueModules = new Set();
    let uniqueSubmodules = new Set();
    let uniqueShards = new Set();
    // Map from module name to set of submodules
    let moduleToSubmodules = {};
    let loadedFiles = [];
    let fileContents = {};
    let currentFileName = null;
    
    // Pagination state
    let currentPageNum = 1;
    let totalPagesCount = 1;
    let filteredEntries = [];
    
    // Shutdown tracking
    let lastShutdownIndex = -1;
    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadingInfo = document.getElementById('loadingInfo');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const errorOverlay = document.getElementById('errorOverlay');
    const errorMessage = document.getElementById('errorMessage');

    function extractModuleParts(caller) {
      // Try to extract module/submodule from caller path
      if (!caller) return {module: '', submodule: ''};
      // Example: /path/to/project/internal/utils/utils.go:207
      // Module: utils, Submodule: internal/utils
      const parts = caller.split('/');
      if (parts.length < 2) return {module: '', submodule: ''};
      const module = parts[parts.length-2];
      const submodule = parts.slice(-3, -1).join('/');
      return {module, submodule};
    }

    function updateLevelFilterOptions() {
      filterLevel.innerHTML = '<option value="">All</option>';
      Array.from(uniqueLevels).sort().forEach(level => {
        filterLevel.innerHTML += `<option value="${level}">${level}</option>`;
      });
    }

    function updateDropdownOptions(selectElem, values) {
      selectElem.innerHTML = '<option value="">All</option>';
      Array.from(values).sort().forEach(val => {
        selectElem.innerHTML += `<option value="${val}">${val}</option>`;
      });
    }

    function updateAllFilterOptions() {
      updateDropdownOptions(filterLevel, uniqueLevels);
      updateDropdownOptions(filterModule, uniqueModules);
      // By default, show all submodules
      updateDropdownOptions(filterSubmodule, uniqueSubmodules);
      updateDropdownOptions(filterShard, uniqueShards);
    }

    function updateSubmoduleDropdownForModule(module) {
      if (!module) {
        // If no module selected, show all submodules
        updateDropdownOptions(filterSubmodule, uniqueSubmodules);
      } else {
        const submods = moduleToSubmodules[module] || new Set();
        updateDropdownOptions(filterSubmodule, submods);
      }
      filterSubmodule.value = '';
    }

        function renderTable() {
      logTableBody.innerHTML = '';
      
      // Apply filters first
      const levelVal = filterLevel.value;
      const msgVal = filterMessage.value.toLowerCase();
      const moduleVal = filterModule.value;
      const submoduleVal = filterSubmodule.value;
      const shardVal = filterShard.value;
      const afterShutdown = filterAfterShutdown.checked;
      
      // Filter entries
      filteredEntries = logEntries.filter((obj, index) => {
        const level = obj.level || '';
        const message = obj.message || '';
        const shard = obj.shardID ?? obj.shard ?? '';
        const caller = obj.caller || '';
        const {module, submodule} = extractModuleParts(caller);
        
        if (levelVal && level !== levelVal) return false;
        if (msgVal && !message.toLowerCase().includes(msgVal)) return false;
        if (moduleVal && module !== moduleVal) return false;
        if (submoduleVal && submodule !== submoduleVal) return false;
        if (shardVal && String(shard) !== shardVal) return false;
        
        // Check shutdown filter (use pre-calculated index)
        if (afterShutdown && lastShutdownIndex !== -1 && index <= lastShutdownIndex) {
          return false;
        }
        
        return true;
      });
      
      // Update pagination
      updatePagination();
      
      // If current page is beyond total pages, reset to first page
      if (currentPageNum > totalPagesCount) {
        currentPageNum = 1;
        updatePagination();
      }
      
      // Render current page
      renderCurrentPage();
    }
    
    function renderCurrentPage() {
      logTableBody.innerHTML = '';
      
      const pageSizeVal = parseInt(pageSize.value);
      const startIndex = (currentPageNum - 1) * pageSizeVal;
      const endIndex = Math.min(startIndex + pageSizeVal, filteredEntries.length);
      
      let rowNum = startIndex + 1;
      
      for (let i = startIndex; i < endIndex; i++) {
        const obj = filteredEntries[i];
        const timeRaw = obj.time || '';
        let time = timeRaw;
        if (timeRaw) {
          // Try to parse and format as YYYY-MM-DD HH:MM:SS
          const d = new Date(timeRaw);
          if (!isNaN(d.getTime())) {
            const pad = n => n.toString().padStart(2, '0');
            time = `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
          }
        }
        
        const level = obj.level || '';
        const message = obj.message || '';
        const shard = obj.shardID ?? obj.shard ?? '';
        
        const tr = document.createElement('tr');
        let rowStyle = '';
        if (level === 'error') rowStyle = 'color:#d32f2f;font-weight:bold;background:#fdeaea;';
        else if (level === 'warn') rowStyle = 'color:#e67c00;font-weight:bold;background:#fff6e0;';
        
        tr.innerHTML = `
          <td>${rowNum}</td>
          <td class="time-col">${time}</td>
          <td>${level}</td>
          <td>${shard}</td>
          <td>${message}</td>
        `;
        
        if (rowStyle) tr.style = rowStyle;
        tr.addEventListener('click', () => showDetails(obj));
        logTableBody.appendChild(tr);
        rowNum++;
      }
    }
    
    function updatePagination() {
      const pageSizeVal = parseInt(pageSize.value);
      totalPagesCount = Math.ceil(filteredEntries.length / pageSizeVal);
      
      if (currentPageNum > totalPagesCount) {
        currentPageNum = totalPagesCount || 1;
      }
      
      totalPages.textContent = totalPagesCount;
      currentPage.value = currentPageNum;
      
      // Update pagination info
      const startIndex = (currentPageNum - 1) * pageSizeVal + 1;
      const endIndex = Math.min(currentPageNum * pageSizeVal, filteredEntries.length);
      let infoText = `Showing ${startIndex}-${endIndex} of ${filteredEntries.length} entries`;
      
      // Add shutdown filter info if active
      if (filterAfterShutdown.checked && lastShutdownIndex !== -1) {
        const totalAfterShutdown = logEntries.length - lastShutdownIndex - 1;
        const filteredOut = logEntries.length - filteredEntries.length;
        infoText += ` (showing ${totalAfterShutdown} entries after shutdown, filtered out ${filteredOut} entries)`;
      }
      
      paginationInfo.textContent = infoText;
      
      // Update button states
      firstPage.disabled = currentPageNum === 1;
      prevPage.disabled = currentPageNum === 1;
      nextPage.disabled = currentPageNum === totalPagesCount;
      lastPage.disabled = currentPageNum === totalPagesCount;
    }

    function applyFilters() {
      renderTable();
    }

    filterLevel.addEventListener('change', applyFilters);
    filterMessage.addEventListener('input', applyFilters);
    filterModule.addEventListener('change', function() {
      updateSubmoduleDropdownForModule(filterModule.value);
      applyFilters();
    });
    filterSubmodule.addEventListener('change', applyFilters);
    filterShard.addEventListener('change', applyFilters);
    filterAfterShutdown.addEventListener('change', function() {
      // Reset to first page when filter changes
      currentPageNum = 1;
      
      // Show notification about what's happening
      if (this.checked && lastShutdownIndex !== -1) {
        const totalAfterShutdown = logEntries.length - lastShutdownIndex - 1;
        loadingInfo.textContent = `Filtering to show only ${totalAfterShutdown} entries after last shutdown...`;
      } else if (!this.checked) {
        loadingInfo.textContent = `Showing all ${logEntries.length} entries...`;
      }
      
      applyFilters();
      
      // Clear the loading info after a short delay
      setTimeout(() => {
        if (loadingInfo.textContent.includes('Filtering') || loadingInfo.textContent.includes('Showing all')) {
          loadingInfo.textContent = '';
        }
      }, 1000);
    });
    
    // Pagination event listeners
    pageSize.addEventListener('change', function() {
      currentPageNum = 1;
      updatePagination();
      renderCurrentPage();
    });
    
    firstPage.addEventListener('click', () => {
      currentPageNum = 1;
      updatePagination();
      renderCurrentPage();
    });
    
    prevPage.addEventListener('click', () => {
      if (currentPageNum > 1) {
        currentPageNum--;
        updatePagination();
        renderCurrentPage();
      }
    });
    
    nextPage.addEventListener('click', () => {
      if (currentPageNum < totalPagesCount) {
        currentPageNum++;
        updatePagination();
        renderCurrentPage();
      }
    });
    
    lastPage.addEventListener('click', () => {
      currentPageNum = totalPagesCount;
      updatePagination();
      renderCurrentPage();
    });
    
    currentPage.addEventListener('change', function() {
      const newPage = parseInt(this.value);
      if (newPage >= 1 && newPage <= totalPagesCount) {
        currentPageNum = newPage;
        updatePagination();
        renderCurrentPage();
      } else {
        this.value = currentPageNum;
      }
    });
    
    clearFilters.addEventListener('click', () => {
      filterLevel.value = '';
      filterMessage.value = '';
      filterModule.value = '';
      filterSubmodule.value = '';
      filterShard.value = '';
      filterAfterShutdown.checked = false;
      currentPageNum = 1;
      renderTable();
    });

    fileInput.addEventListener('change', function(e) {
      hideError();
      const files = Array.from(e.target.files);
      loadedFiles = files;
      fileContents = {};
      fileList.innerHTML = '';
      if (files.length === 0) {
        logEntries = [];
        renderTable();
        return;
      }
      files.forEach((file, idx) => {
        const li = document.createElement('li');
        li.textContent = file.name;
        li.style.cursor = 'pointer';
        li.style.padding = '0.3em 0.5em';
        li.style.borderRadius = '4px';
        li.style.marginBottom = '2px';
        li.setAttribute('data-filename', file.name);
        li.addEventListener('click', () => {
          selectFile(file.name);
        });
        fileList.appendChild(li);
      });
      // Auto-select the first file
      selectFile(files[0].name);
      // Read all files and cache their contents
      files.forEach(file => {
        const reader = new FileReader();
        reader.onload = function(event) {
          fileContents[file.name] = event.target.result;
          // If this file is currently selected, load it
          if (file.name === currentFileName) {
            loadLogFileContent(event.target.result);
          }
         // Analyze file for log level and color the list item
         setTimeout(() => {
           try {
             let text = event.target.result;
             // Try JSONL first
             let lines = text.split(/\r?\n/);
             let foundError = false, foundWarn = false;
             for (let i = 0; i < lines.length; ++i) {
               const line = lines[i];
               if (!line.trim()) continue;
               try {
                 const obj = JSON.parse(line);
                 if (obj.level === 'error') { foundError = true; break; }
                 if (obj.level === 'warn') foundWarn = true;
               } catch {}
             }
             if (!foundError && !foundWarn) {
               // Try pretty-printed JSON objects
               let buffer = '', depth = 0, inObject = false;
               for (let i = 0; i < text.length; ++i) {
                 const c = text[i];
                 if (c === '{') { if (depth === 0) inObject = true; depth++; }
                 if (inObject) buffer += c;
                 if (c === '}') {
                   depth--;
                   if (depth === 0 && inObject) {
                     try {
                       const obj = JSON.parse(buffer);
                       if (obj.level === 'error') { foundError = true; break; }
                       if (obj.level === 'warn') foundWarn = true;
                     } catch {}
                     buffer = '';
                     inObject = false;
                   }
                 }
               }
             }
             const li = fileList.querySelector('li[data-filename="' + file.name.replace(/"/g, '\\"') + '"]');
             if (li) {
               if (foundError) {
                 li.style.color = '#000';
                 li.style.fontWeight = '';
               } else if (foundWarn) {
                 li.style.color = '#000';
                 li.style.fontWeight = '';
               } else {
                 li.style.color = '#000';
                 li.style.fontWeight = '';
               }
             }
           } catch {}
         }, 0);
        };
        reader.readAsText(file);
      });
    });

    function selectFile(fileName) {
      hideError();
      currentFileName = fileName;
      // Highlight selected file
      Array.from(fileList.children).forEach(li => {
        if (li.textContent === fileName) {
          li.style.background = '#d0eaff';
          li.style.fontWeight = 'bold';
        } else {
          li.style.background = '';
          li.style.fontWeight = '';
        }
      });
      if (fileContents[fileName]) {
        loadLogFileContent(fileContents[fileName]);
      }
    }

    function showError(msg) {
      errorMessage.textContent = msg;
      errorOverlay.style.display = 'flex';
    }

    function hideError() {
      errorOverlay.style.display = 'none';
    }

    function loadLogFileContent(text) {
      hideError();
      // Show loading overlay
      loadingOverlay.style.display = 'flex';
      loadingInfo.textContent = '';
      progressBar.style.width = '0%';
      progressText.textContent = '0%';
      
      // Fast line counting first (without parsing)
      let lines = text.split(/\r?\n/);
      let lineCount = 0;
      let validLineIndices = [];
      
      // Count valid lines and store their indices
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (line && line.startsWith('{') && line.endsWith('}')) {
          validLineIndices.push(i);
          lineCount++;
        }
      }
      
      if (lineCount === 0) {
        showError('No valid JSON lines found in the file.');
        loadingOverlay.style.display = 'none';
        return;
      }
      
      loadingInfo.textContent = `Processing ${lineCount} lines...`;
      
      // Process all lines efficiently (no more 100K limit)
      processLinesEfficiently(lines, validLineIndices, 0, lineCount);
    }
    
    function processLinesEfficiently(lines, validLineIndices, startIndex, totalLinesToProcess) {
      // Initialize data structures
      logEntries = [];
      uniqueLevels = new Set();
      uniqueModules = new Set();
      uniqueSubmodules = new Set();
      uniqueShards = new Set();
      moduleToSubmodules = {};
      
      // Reset shutdown index for new file
      lastShutdownIndex = -1;
      
      let processedCount = 0;
      let currentProgress = 0;
      
      // Process lines in chunks for smooth UI updates
      const chunkSize = 5000; // Increased for better performance
      let currentChunkStart = 0;
      
      function processChunk() {
        const chunkEnd = Math.min(currentChunkStart + chunkSize, totalLinesToProcess);
        
        for (let i = currentChunkStart; i < chunkEnd; i++) {
          const lineIndex = validLineIndices[startIndex + i];
          const line = lines[lineIndex];
          
          try {
            const obj = JSON.parse(line);
            if (!obj) continue;
            
            // Add to log entries
            logEntries.push(obj);
            
            // Extract and store unique values
            if (obj.level) uniqueLevels.add(obj.level);
            
            const caller = obj.caller || '';
            const {module, submodule} = extractModuleParts(caller);
            if (module) uniqueModules.add(module);
            if (submodule) uniqueSubmodules.add(submodule);
            if (module) {
              if (!moduleToSubmodules[module]) moduleToSubmodules[module] = new Set();
              if (submodule) moduleToSubmodules[module].add(submodule);
            }
            
            const shard = obj.shardID ?? obj.shard;
            if (shard !== undefined && shard !== null && shard !== '') uniqueShards.add(String(shard));
            
            // Check for shutdown message (store globally for reuse)
            if (obj.message && obj.message.includes('Blockchain manager stopped')) {
              lastShutdownIndex = processedCount;
            }
            
            processedCount++;
          } catch (err) {
            // Skip invalid lines
            processedCount++;
          }
        }
        
        // Update progress (cap at 100%)
        currentProgress = Math.min(Math.round((processedCount / totalLinesToProcess) * 100), 100);
        progressBar.style.width = currentProgress + '%';
        progressText.textContent = currentProgress + '%';
        
        // Process next chunk or finish
        if (processedCount < totalLinesToProcess) {
          currentChunkStart = chunkEnd;
          requestAnimationFrame(processChunk);
        } else {
          // Finished processing
          updateAllFilterOptions();
          updateSubmoduleDropdownForModule(filterModule.value);
          
          // Reset pagination
          currentPageNum = 1;
          updatePagination();
          
          // Render first page
          renderTable();
          loadingOverlay.style.display = 'none';
          
          // Show info about shutdown detection
          if (lastShutdownIndex !== -1) {
            loadingInfo.textContent = `Found shutdown message at line ${lastShutdownIndex + 1} of ${totalLinesToProcess} processed lines. Use "After last shutdown" filter to see only recent logs.`;
          } else {
            loadingInfo.textContent = `No shutdown message found in ${totalLinesToProcess} processed lines. All logs are from current session.`;
          }
        }
      }
      
      // Start processing
      processChunk();
    }



    function showDetails(obj) {
      jsonDetails.textContent = JSON.stringify(obj, null, 2);
      modal.style.display = 'flex';
    }

    closeModal.onclick = function() {
      modal.style.display = 'none';
    };
    window.onclick = function(event) {
      if (event.target === modal) {
        modal.style.display = 'none';
      }
    };
  </script>
</body>
</html> 